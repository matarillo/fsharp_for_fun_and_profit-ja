---
layout: post
title: "内向的・外向的なプログラミング言語"
description: "深夜に思いついた、言語の性格タイプ"
categories: []
---

> 内向的な数学者と外向的な数学者の違いは何でしょう？
> 
> 内向的な数学者は、あなたと話している間、自分の靴を見つめます。外向的な数学者は、*あなたの*靴を見つめます。

私は以前から、プログラミング言語の外界に対するふるまい方が[違う](https://plus.google.com/110981030061712822816/posts/KaSKeg4vQtz)ことに気づいていました。

もしプログラミング言語に性格があるとしたら、そのうちのいくつかを「内向的」、いくつかを「外向的」と呼びたいです。

外向的なプログラミング言語は、外界がすべてであり、IOや外部データソースとパーティーをしている時が一番幸せです。

一方、内向的なプログラミング言語は、一人でいることに満足しており、可能であれば外界と関わりたくないと思っています。
もちろん、必要であれば社交的で、IOと連携することもできますが、その活動をかなり疲れると感じ、IOが家に帰って、良い本を読んでリラックスできるようになると安心します。

興味深いのは、ユーザーガイドやチュートリアルで何が重要とされているかを見ることで、言語の性格タイプについて多くのことがわかるということです。

たとえば、古典的な「プログラミング言語C」の本では、冒頭に`printf("hello, world\n")` があることが[有名です](https://books.google.co.uk/books?id=va1QAAAAMAAJ&focus=searchwithinvolume&q=hello%2C+world)し、
他のほとんどのCの本も[同様です](https://en.wikibooks.org/wiki/C_Programming/A_taste_of_C)。

そして実際、Cは*非常に*外向的な言語です。コーディング例には、ファイルやコンソールIOが散りばめられています。
同様に、PHP、Python、Perlが同じくらい外向的であることは、マニュアルを一目見ただけでわかります。

実際、最も人気のある言語は*すべて*外向的であると言えるでしょう。理由は明らかです。
彼らは自信に満ち溢れ、簡単に友達を作り、物事を成し遂げます。

一方、Haskellは内向的な言語の素晴らしい例と言えるでしょう。

たとえば、「すごいHaskellたのしく学ぼう!」という本では、「hello world」の例は[9章](https://learnyouahaskell.com/input-and-output#hello-world)まで出てきません！
また、「Real World Haskell」では、IOは[7章](https://book.realworldhaskell.org/read/io.html)まで夕食に招待されません。

完全なマニュアルが手元にない場合、言語が内向的であることを示すもう1つの手がかりは、早い段階で親友であるフィボナッチ関数を紹介することです。
内向的な言語は再帰が大好きです！

さて、現実世界と同じように、内向的な言語は外向的な人には誤解されています。彼らは、傲慢すぎるとか、真面目すぎるとか、リスク回避しすぎるとか非難されます。

しかし、それは公平ではありません。内向的な言語は、実際にはより思慮深く、考え深いので、浅はかでやかましい外向的な言語よりも深い洞察を得る可能性が高いのです。


### しかし...

> 「すべての一般化は誤りである、この言葉も含めて。」

命令型やOO言語は外向的で、より宣言的なパラダイム（関数型、論理型）を持つ言語は内向的だと考えるかもしれませんが、
必ずしもそうではありません。

たとえば、SQLは宣言型言語ですが、その人生の目的はデータ処理であり、それは私の考えでは外向的です。

そして、より身近なところでは、F#は関数型ファーストの言語ですが、IOにも適しています。
実際、[型プロバイダー](https://blogs.msdn.com/b/dsyme/archive/2013/01/30/twelve-type-providers-in-pictures.aspx)や[Deedle](https://bluemountaincapital.github.io/Deedle/)を介して、
現実世界のデータ処理を非常にうまくサポートしています。

人がすべてどちらか一方であるわけではないように、プログラミング言語も同様です。
幅があるのです。非常に外向的な言語もあれば、非常に内向的な言語もあり、その中間の言語もあります。

### 多くの人が私を自己中心的だと言うが、彼らのことはもういい

> 「現実は単なる幻想に過ぎない。とはいえ、非常にしつこい幻想だが。」

この性格タイプ分類にきちんと収まらない言語もあります。

Smalltalkを例に挙げましょう。

多くの点で、Smalltalkは*非常に*外向的です。ユーザーインターフェースの相互作用をサポートする機能が豊富にあり、
最初期の[グラフィカル開発環境](https://arstechnica.com/features/2005/05/gui/3/)のひとつでした。

しかし、問題があります。確かに、フレンドリーでおしゃべりで、1対1の濃厚な会話は得意ですが、暗い一面があります。それは、他人と仲良くできないことです。
オペレーティングシステムだけは渋々認めますが、粗雑な外部ライブラリを使うより、独自の完璧な方法で物事を実装することを好みます。

ほとんどのLispにも同じ欠点があります。理想主義的でエレガントですが、やや孤立しています。
私はこの性格タイプを[独我論的](https://www.merriam-webster.com/dictionary/solipsism)と呼ぶことにします。

彼らの弁護をしておくと、多くの重要なプログラミングの概念は、独我論的な言語で最初に開発されました。
しかし、悲しいかな、熱心な支持者にもかかわらず、広く普及し、正当な評価を得ることはありません。

### 我々はどこから来たのか、我々は何者か、我々はどこへ行くのか

そして、この話題は必然的に、すべてを飲み込むブラックホールであるJavaScriptへ向かいます。馬鹿げたスキームではありますが、JavaScriptはどこに当てはまるのでしょうか？

JavaScriptの本来の目的は、ユーザーとのコミュニケーションを支援すること（そして、猿をアニメーション化すること）だったのは明らかですから、一見すると外向的に見えます。

しかし、JavaScriptがサンドボックス内で実行されるという事実（そして、つい最近までさまざまな種類のIOを扱えなかったこと）を考えると、JavaScriptは実は内向的な言語なのではないか、という気がしてきます。
決め手になったのは、node.jsです。サーバーサイド言語が必要ですか？私たちの流儀で作成しましょう！必要なライブラリはすべてゼロから書きましょう！

しかし、少なくとも今のところは、その態度でうまくいったようです。ということで、独我論的で決まりです！

### 非科学的な結論

> 「自然は我々を軽薄に作り、我々の苦しみを慰めようとした。」

最後に、さまざまなプログラミングコミュニティの特徴や、コミュニティ参加者が好むプログラミング言語からどのようなことが明らかになるのか、といった深い考察をまとめるべきかもしれません。

しかし、実際には、この記事はちょっとした気まぐれで書いただけなので、そのような考察はしません。





