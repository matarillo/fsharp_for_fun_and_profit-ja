# Summary


### スタートガイド

* [はじめに](README.md)
* [本の内容](site-contents/index.md) 
* [「F# を使う理由」を1ページで解説](why-use-fsharp/index.md) 
* [F# のインストールと使い方](installing-and-using/index.md)
* [60 秒でわかる F# シンタックス](posts/fsharp-in-60-seconds.md) 
* [F# を学ぶ](learning-fsharp/index.md)
* [F# のトラブルシューティング](troubleshooting-fsharp/index.md)
* [仕事で F# を使う低リスクな方法](series/low-risk-ways-to-use-fsharp-at-work.md) 
  * [仕事で F# を使う 26 の低リスクな方法](posts/low-risk-ways-to-use-fsharp-at-work.md)
  * [開発と Devops スクリプトに F# を使う](posts/low-risk-ways-to-use-fsharp-at-work-2.md)
  * [テストに F# を使う](posts/low-risk-ways-to-use-fsharp-at-work-3.md)
  * [データベース関連タスクに F# を使う](posts/low-risk-ways-to-use-fsharp-at-work-4.md)
  * [仕事で F# を使うその他の興味深い方法](posts/low-risk-ways-to-use-fsharp-at-work-5.md)

### F# を使う理由

* [「F# を使う理由」シリーズ](series/why-use-fsharp.md) 
  * [F# を使う理由シリーズの紹介](posts/why-use-fsharp-intro.md) 
  * [60 秒でわかる F# シンタックス](posts/fsharp-in-60-seconds.md) 
  * [C# と F# の比較: 簡単な合計](posts/fvsc-sum-of-squares.md) 
  * [C# と F# の比較: ソート](posts/fvsc-quicksort.md) 
  * [C# と F# の比較: Webページのダウンロード](posts/fvsc-download.md)
  * [F# の 4 つの重要概念](posts/key-concepts.md) 
  * [簡潔さ](posts/conciseness-intro.md) 
  * [型推論](posts/conciseness-type-inference.md) 
  * [低オーバーヘッドの型定義](posts/conciseness-type-definitions.md)
  * [ボイラープレートコードを抽出するための関数を使う](posts/conciseness-extracting-boilerplate.md)
  * [ビルディングブロックとしての関数を使う](posts/conciseness-functions-as-building-blocks.md) 
  * [簡潔さのためのパターンマッチング](posts/conciseness-pattern-matching.md) 
  * [便利さ](posts/convenience-intro.md) 
  * [型に関する既定のふるまい](posts/convenience-types.md) 
  * [インターフェースとしての関数](posts/convenience-functions-as-interfaces.md) 
  * [部分適用](posts/convenience-partial-application.md) 
  * [アクティブパターン](posts/convenience-active-patterns.md)
  * [正確性](posts/correctness-intro.md) 
  * [不変性](posts/correctness-immutability.md) 
  * [網羅的なパターンマッチング](posts/correctness-exhaustive-pattern-matching.md)
  * [型システムを使用した正しいコードの確保](posts/correctness-type-checking.md) 
  * [実践例: 正確性のための設計](posts/designing-for-correctness.md) 
  * [並行処理](posts/concurrency-intro.md) 
  * [非同期プログラミング](posts/concurrency-async-and-parallel.md) 
  * [メッセージとエージェント](posts/concurrency-actor-model.md) 
  * [関数型リアクティブプログラミング](posts/concurrency-reactive.md) 
  * [完全性](posts/completeness-intro.md)
  * [シームレスな .NET ライブラリとの相互運用](posts/completeness-seamless-dotnet-interop.md) 
  * [C# でできることは何でも...](posts/completeness-anything-csharp-can-do.md) 
  * [F# を使う理由: 結論](posts/why-use-fsharp-conclusion.md)

### 関数型思考

* [「関数型思考」 シリーズ](series/thinking-functionally.md) 
  * [関数型思考: はじめに](posts/thinking-functionally-intro.md)
  * [数学関数](posts/mathematical-functions.md)
  * [関数値と単純値](posts/function-values-and-simple-values.md)
  * [型と関数のしくみ](posts/how-types-work-with-functions.md)
  * [カリー化](posts/currying.md)
  * [部分適用](posts/partial-application.md)
  * [関数の結合性と合成](posts/function-composition.md)
  * [関数の定義](posts/defining-functions.md)
  * [関数シグネチャ](posts/function-signatures.md)
  * [関数の整理](posts/organizing-functions.md)
  * [型への関数のアタッチ](posts/type-extensions.md)
  * [実践例: スタックベースの電卓](posts/stack-based-calculator.md)

### F# を理解する ###

* [「式と構文」 シリーズ](series/expressions-and-syntax.md)        
  * [式と構文: はじめに](posts/expressions-intro.md)
  * [式 vs. 文](posts/expressions-vs-statements.md)
  * [F# 式の概要](posts/understanding-fsharp-expressions.md)
  * [let、use、doでの束縛](posts/let-use-do.md)
  * [F# 構文: インデントと冗長性](posts/fsharp-syntax.md)
  * [パラメーターと値の名前付け規則](posts/naming-conventions.md)
  * [制御フロー式](posts/control-flow-expressions.md)
  * [例外](posts/exceptions.md)
  * [マッチ式](posts/match-expression.md)
  * [printf によるフォーマット済みテキスト](posts/printf.md)
  * [実践例: コマンドライン引数の解析](posts/pattern-matching-command-line.md)
  * [実践例: ローマ数字](posts/roman-numerals.md)
* [「F# の型を理解する」 シリーズ](series/understanding-fsharp-types.md)            
  * [F# の型を理解する: はじめに](posts/types-intro.md)
  * [F# の型概要](posts/overview-of-types-in-fsharp.md)
  * [型略称](posts/type-abbreviations.md)
  * [タプル](posts/tuples.md)
  * [レコード](posts/records.md)
  * [判別共用体](posts/discriminated-unions.md)
  * [オプション型](posts/the-option-type.md)
  * [列挙型](posts/enum-types.md)
  * [組み込みの .NET 型](posts/cli-types.md)
  * [測定単位](posts/units-of-measure.md)
  * [型推論を理解する](posts/type-inference.md)
* [コレクション関数の選択](posts/list-module-functions.md)        
* [「F# でのオブジェクト指向プログラミング」 シリーズ](series/object-oriented-programming-in-fsharp.md)    
  * [F# でのオブジェクト指向プログラミング: はじめに](posts/object-oriented-intro.md)
  * [クラス](posts/classes.md)
  * [継承と抽象クラス](posts/inheritance.md)
  * [インターフェイス](posts/interfaces.md)
  * [オブジェクト式](posts/object-expressions.md)
* [「コンピュテーション式」 シリーズ](series/computation-expressions.md)    
  * [コンピュテーション式: はじめに](posts/computation-expressions-intro.md)
  * [継続の理解](posts/computation-expressions-continuations.md)
  * [bind の紹介](posts/computation-expressions-bind.md)
  * [コンピュテーション式とラッパー型](posts/computation-expressions-wrapper-types.md)
  * [ラッパー型について](posts/computation-expressions-wrapper-types-part2.md)
  * [ビルダーの実装: Zero と Yield](posts/computation-expressions-builder-part1.md)
  * [ビルダーの実装: Combine](posts/computation-expressions-builder-part2.md)
  * [ビルダーの実装: Delay と Run](posts/computation-expressions-builder-part3.md)
  * [ビルダーの実装: オーバーロード](posts/computation-expressions-builder-part4.md)
  * [ビルダーの実装:遅延の追加](posts/computation-expressions-builder-part5.md)
  * [ビルダーの実装: 標準メソッドの残りの部分](posts/computation-expressions-builder-part6.md)
* [プロジェクト内のモジュールの整理](posts/recipe-part3.md)   
* [「循環依存」 シリーズ](series/dependency-cycles.md)    
  * [循環依存は悪](posts/cyclic-dependencies.md)
  * [循環依存を取り除くリファクタリング](posts/removing-cyclic-dependencies.md)
  * [実世界の循環依存とモジュール性](posts/cycles-and-modularity-in-the-wild.md)
* [「C# からの移植」 シリーズ](series/porting-from-csharp.md)    
  * [C# から F# への移植: はじめに](posts/porting-to-csharp-intro.md)
  * [直接移植の始め方](posts/porting-to-csharp-getting-started.md)

### 関数型設計 ###

* [「型を使って設計する」 シリーズ](series/designing-with-types.md)           
  * [型を使って設計する: はじめに](posts/designing-with-types-intro.md)
  * [単一ケース共用体型](posts/designing-with-types-single-case-dus.md)
  * [不正な状態を表現できないようにする](posts/designing-with-types-making-illegal-states-unrepresentable.md)
  * [新しい概念を発見する](posts/designing-with-types-discovering-the-domain.md)
  * [状態を明示的にする](posts/designing-with-types-representing-states.md)
  * [制約付き文字列](posts/designing-with-types-more-semantic-types.md)
  * [文字列以外の型](posts/designing-with-types-non-strings.md)
  * [型を使って設計する: 結論](posts/designing-with-types-conclusion.md)
* [代数型サイズとドメインモデリング](posts/type-size-and-design.md)
* [カメの十三通りの見方](posts/13-ways-of-looking-at-a-turtle.md)
  * [カメの十三通りの見方 (パート2)](posts/13-ways-of-looking-at-a-turtle-2.md)
  * [カメの十三通りの見方 - 補遺](posts/13-ways-of-looking-at-a-turtle-3.md)
    
### 関数型パターン ###

* [完全なプログラムの設計とコーディング方法](posts/recipe-part1.md)   
* [エラー処理への関数型アプローチ (鉄道指向プログラミング)](posts/recipe-part2.md)   
  * [鉄道指向プログラミング: 炭酸飲料エディション](posts/railway-oriented-programming-carbonated.md)
* [「モノイドを理解する」 シリーズ](series/understanding-monoids.md)           
  * [つらくないモノイド](posts/monoids-without-tears.md)
  * [実践的なモノイド](posts/monoids-part2.md)
  * [モノイド以外を扱う](posts/monoids-part3.md)
* [「パーサコンビネータを理解する」 シリーズ](series/understanding-parser-combinators.md)   
  * [パーサコンビネータを理解する](posts/understanding-parser-combinators.md)
  * [便利なパーサコンビネータセットの作成](posts/understanding-parser-combinators-2.md)
  * [パーサライブラリの改善](posts/understanding-parser-combinators-3.md)
  * [スクラッチから JSON パーザを書く](posts/understanding-parser-combinators-4.md)
* [「状態の扱い」 シリーズ](series/handling-state.md)       
  * [フランケン関手博士とモナドスター](posts/monadster.md)
  * [モナドスターの本体を完成させる](posts/monadster-2.md)
  * [モナドスターのリファクタリング](posts/monadster-3.md)
* [「Map, Bind, Apply のお祭り騒ぎ」 シリーズ](series/map-and-bind-and-apply-oh-my.md)       
  * [map と apply を理解する](posts/elevated-world.md)
  * [bind を理解する](posts/elevated-world-2.md)
  * [コア関数の実際的な使い方](posts/elevated-world-3.md)
  * [traverse と sequence を理解する](posts/elevated-world-4.md)
  * [map, apply, bind, sequence を仕事で使う](posts/elevated-world-5.md)
  * [Reader モナドの再発明](posts/elevated-world-6.md)
  * [Map, Bind, Apply まとめ](posts/elevated-world-7.md)
* [「再帰型と畳み込み」 シリーズ](series/recursive-types-and-folds.md)       
  * [再帰型入門](posts/recursive-types-and-folds.md)
  * [カタモーフィズムの例](posts/recursive-types-and-folds-1b.md)
  * [畳み込みの紹介](posts/recursive-types-and-folds-2.md)
  * [畳み込みを理解する](posts/recursive-types-and-folds-2b.md)
  * [ジェネリック再帰型](posts/recursive-types-and-folds-3.md)
  * [木構造の実践的な利用](posts/recursive-types-and-folds-3b.md)
* [「認可の関数型アプローチ」 シリーズ](series/a-functional-approach-to-authorization.md)       
  * [認可の関数型アプローチ](posts/capability-based-security.md)
  * [ID とロールに基づく機能の制約](posts/capability-based-security-2.md)
  * [型をアクセス トークンとして使う](posts/capability-based-security-3.md)

### テスト

* [プロパティベースドテストのはじめに](posts/property-based-testing.md)
* [プロパティベースドテストのプロパティ選択](posts/property-based-testing-2.md)

### 例とチュートリアル

* [実践例: 正しさのための設計](posts/designing-for-correctness.md) 
* [実践例: スタックベースの電卓](posts/stack-based-calculator.md)
* [実践例: コマンドライン引数の解析](posts/pattern-matching-command-line.md)
* [実践例: ローマ数字](posts/roman-numerals.md)
* [「解説付きローマ数字カタ」の解説](posts/roman-numeral-kata.md)
* [電卓チュートリアル: パート1](posts/calculator-design.md)
  * [電卓チュートリアル: パート2](posts/calculator-implementation.md)
  * [電卓チュートリアル: パート3](posts/calculator-complete-v1.md)
  * [電卓チュートリアル: パート4](posts/calculator-complete-v2.md)
* [エンタープライズ三目並べ](posts/enterprise-tic-tac-toe.md).
  * [エンタープライズ三目並べ パート2](posts/enterprise-tic-tac-toe-2.md)
* [スクラッチから JSON パーザを書く](posts/understanding-parser-combinators-4.md)

### その他

* [静的型付け関数型プログラミング言語を使わない10の理由](posts/ten-reasons-not-to-use-a-functional-programming-language.md)
* [なぜモナドチュートリアルを書かないのか](posts/why-i-wont-be-writing-a-monad-tutorial.md)
* [あなたのプログラミング言語は非常識ですか？](posts/is-your-language-unreasonable.md)
* [くだらない UML 図なんか要らない](posts/no-uml-diagrams.md)
* [内向型と外向型プログラミング言語](posts/introvert-vs-extrovert.md)
* [コンパイラ指令で型安全性を犠牲にして高速化](posts/typesafe-performance-with-compiler-directives.md)
