---
layout: page
title: "Site Contents"
nav: site-contents
description: "A directory of useful pages"
hasIcons: 1
hasNoCode: 1
---


## Getting started

* [Installing and using F#](../installing-and-using/index.md) will get you started.
* [Why use F#?](../why-use-fsharp/index.md) An interactive tour of F#.
* [Learning F#](../learning-fsharp/index.md) has tips to help you learn more effectively. 
* [Troubleshooting F#](../troubleshooting-fsharp/index.md) for when you have problems getting your code to compile.

and then you can try...

* [Twenty six low-risk ways to use F# at work](../posts/low-risk-ways-to-use-fsharp-at-work.md). You can start right now -- no permission needed!

## 学習の始め方

* [F# のインストールと使い方](../installing-and-using/index.md) を最初に読むとよいでしょう。
* [F# を使う理由](../why-use-fsharp/index.md) F# のインタラクティブツアー
* [F# の学習](../learning-fsharp/index.md) より効果的に学習するためのヒント
* F# で問題が発生したときは、[F# のトラブルシューティング](../troubleshooting-fsharp/index.md) を参照してください。

さらに以下のことも試すことができます。

* [実務で F# を使う低リスクな 26 の方法](../posts/low-risk-ways-to-use-fsharp-at-work.md)。 今すぐ始めることができます - 許可は必要ありません!

## Tutorials

The following series are tutorials on the key concepts of F#. 

* [Thinking functionally](../series/thinking-functionally.md) starts from basics and explains how and why functions work the way they do.
* [Expressions and syntax](../series/expressions-and-syntax.md) covers the common expressions such as pattern matching, and has a post on indentation.
* [Understanding F# types](../series/understanding-fsharp-types.md) explains how to define and use the various types, including tuples, records, unions, and options.
* [Designing with types](../series/designing-with-types.md) explains how to use types as part of the design process, making illegal states unrepresentable.
* [Choosing between collection functions](../posts/list-module-functions.md). If you are coming to F# from C#, the large number of list functions can be overwhelming, so I have written this post to help guide you to the one you want.
* [Property-based testing](../posts/property-based-testing.md): the lazy programmer's guide to writing 1000's of tests.
* [Understanding computation expressions](../series/computation-expressions.md) demystifies them and shows how you can create your own.

## チュートリアル

次のシリーズは、F# の主要な概念に関するチュートリアルです。

* [関数型思考](../series/thinking-functionally.md) は基本から始めて、関数がどのように機能するのか、その理由を説明します。
* [式と構文](../series/expressions-and-syntax.md) は、パターンマッチングなどの一般的な式をカバーし、インデントについてのポストがあります。
* [F# の型を理解する](../series/understanding-fsharp-types.md) は、タプル、レコード、共用体、オプションなど、さまざまな型を定義して使用するしくみを説明します。
* [型による設計](../series/designing-with-types.md) は、型を設計プロセスの一部として使用する方法と、不正な状態を表現不可能にする方法を説明します。
* [コレクション関数の選択](../posts/list-module-functions.md)。 C# から F# に移行する場合、膨大な数のリスト関数が難しく感じるかもしれないので、目的の関数を見つけるためのガイドとしてこのポストを書きました。
* [プロパティベースドテスト](../posts/property-based-testing.md): 何千ものテストを書くための怠け者のプログラマーのためのガイドです。
* [コンピュテーション式の理解](../series/computation-expressions.md) は、コンピュテーション式を解明し、独自のコンピュテーション式を作成する方法を示します。

## Functional patterns

These posts explain some core patterns in functional programming -- concepts such as "map", "bind", monads and more.

* [Railway Oriented Programming](../posts/recipe-part2.md): A functional approach to error handling
* [State Monad](../series/handling-state.md): An introduction to handling state using the tale of Dr Frankenfunctor and the Monadster.
* [Reader Monad](../posts/elevated-world-6.md): Reinventing the Reader monad.
* [Map, bind, apply, lift, sequence and traverse](../series/map-and-bind-and-apply-oh-my.md): A series describing some of the core functions for dealing with generic data types. 
* [Monoids without tears](../posts/monoids-without-tears.md): A mostly mathless discussion of a common functional pattern.
* [Fold and recursive types](../series/recursive-types-and-folds.md): A look at recursive types, catamorphisms, tail recursion, the difference between left and right folds, and more.
* [Understanding Parser Combinators](../posts/understanding-parser-combinators.md): Creating a parser combinator library from scratch.
* [Thirteen ways of looking at a turtle](../posts/13-ways-of-looking-at-a-turtle.md): demonstrates many different techniques for implementing a turtle graphics API, including state monads, agents, interpreters, and more!

## 関数型パターン

これらの記事では、関数型プログラミングにおけるコアとなるパターン、つまり "map", "bind"、モナドなどの概念について説明します。

* [鉄道指向プログラミング](../posts/recipe-part2.md): エラー処理のための関数型アプローチ
* [State モナド](../series/handling-state.md): フランケンファンクター博士とモナドスターの物語を使って、状態の扱いを紹介する。
* [Reader モナド](../posts/elevated-world-6.md): Reader モナドの再考
* [Map, bind, apply, lift, sequence, traverse](../series/map-and-bind-and-apply-oh-my.md): ジェネリックデータ型を扱うためのコア関数の一部を説明するシリーズ
* [つらくないモナド](../posts/monoids-without-tears.md): 一般的な関数型パターンのほとんど数学を使わない解説です。
* [フォールドと再帰型](../series/recursive-types-and-folds.md): 再帰型、カタモーフィズム、末尾再帰、左フォールドと右フォールドの違いなどについて説明します。
* [パーサーコンビネータの理解](../posts/understanding-parser-combinators.md): パーサーコンビネータライブラリをスクラッチから作成する。
* [カメを見る 13 の方法](../posts/13-ways-of-looking-at-a-turtle.md): 状態モナド、エージェント、インタープリタなど、さまざまな手法を使ってタートルグラフィック API を実装する

## Worked examples

These posts provide detailed worked examples with lots of code!

* [Designing for correctness](../posts/designing-for-correctness.md): How to make illegal states unrepresentable (a shopping cart example).
* [Stack based calculator](../posts/stack-based-calculator.md): Using a simple stack to demonstrate the power of combinators.
* [Parsing commmand lines](../posts/pattern-matching-command-line.md): Using pattern matching in conjunction with custom types.
* [Roman numerals](../posts/roman-numerals.md): Another pattern matching example.
* [Calculator Walkthrough](../posts/calculator-design.md): The type-first approach to designing a Calculator.
* [Enterprise Tic-Tac-Toe](../posts/enterprise-tic-tac-toe.md): A walkthrough of the design decisions in a purely functional implementation
* [Writing a JSON Parser](../posts/understanding-parser-combinators-4.md).

## 動作例

これらの記事では、コードを大量に含んだ詳細な動作例を提供します。

* [正しい設計](../posts/designing-for-correctness.md): 不正な状態を表現不可能にする方法 (ショッピングカートの例)
* [スタックベースの電卓](../posts/stack-based-calculator.md): コンビネータのパワーをデモするためにシンプルなスタックを使用する
* [コマンドラインの解析](../posts/pattern-matching-command-line.md): カスタム型と組み合わせたパターンマッチングの使用
* [ローマ数字](../posts/roman-numerals.md): もう一つのパターンマッチングの例
* [電卓ウォークスルー](../posts/calculator-design.md): 電卓を設計するための型優先アプローチ
* [エンタープライズ三目並べ](../posts/enterprise-tic-tac-toe.md): 純粋な関数型実装における設計上の意思決定のウォークスルー
* [JSON パーサーを書く](../posts/understanding-parser-combinators-4.md)

## Specific topics in F# ##

General:

* [Four key concepts](../posts/key-concepts.md) that differentiate F# from a standard imperative language.
* [Understanding F# indentation](../posts/fsharp-syntax.md).
* [The downsides of using methods](../posts/type-extensions.md#downsides-of-methods).

Functions:

* [Currying](../posts/currying.md).
* [Partial Application](../posts/partial-application.md).
  
Control Flow: 

* [Match..with expressions](../posts/match-expression.md) and [creating folds to hide the matching](../posts/match-expression.md#folds).
* [If-then-else and loops](../posts/control-flow-expressions.md).
* [Exceptions](../posts/exceptions.md). 

Types: 

* [Option Types](../posts/the-option-type.md) especially on why [None is not the same as null](../posts/the-option-type.md#option-is-not-null).
* [Record Types](../posts/records.md).
* [Tuple Types](../posts/tuples.md).
* [Discriminated Unions](../posts/the-option-type.md).
* [Algebraic type sizes and domain modelling](../posts/type-size-and-design.md).

## F# の特定のトピック

一般:

* [4 つの主要な概念](../posts/key-concepts.md) F# を標準的な命令型言語と区別するものです。
* [F# のインデントの理解](../posts/fsharp-syntax.md)
* [メソッドを使用する際の落とし穴](../posts/type-extensions.md#downsides-of-methods)

関数:

* [カリー化](../posts/currying.md)
* [部分適用](../posts/partial-application.md)

制御フロー:

* [Match..with 式](../posts/match-expression.md) と [マッチングを隠すためにフォールドを作成する](../posts/match-expression.md#folds)
* [if-then-else とループ](../posts/control-flow-expressions.md)
* [例外](../posts/exceptions.md)

型:

* [オプション型](../posts/the-option-type.md) 特に [None は null と同じではない](../posts/the-option-type.md#option-is-not-null) の理由
* [レコード型](../posts/records.md)
* [タプル型](../posts/tuples.md)
* [識別された共用体](../posts/the-option-type.md)
* [代数型サイズとドメインモデリング](../posts/type-size-and-design.md)

## Controversial posts

* [Is your programming language unreasonable?](../posts/is-your-language-unreasonable.md) or, why predictability is important.
* [Commentary on 'Roman Numerals Kata with Commentary'](../posts/roman-numeral-kata.md). My approach to the Roman Numerals Kata.
* [Ten reasons not to use a statically typed functional programming language](../posts/ten-reasons-not-to-use-a-functional-programming-language.md). A rant against something I don't get.
* [We don't need no stinking UML diagrams](../posts/no-uml-diagrams.md) or, why in many cases, using UML for class diagrams is not necessary.

## 議論の余地のある記事

* [あなたのプログラミング言語は理不尽ですか？](../posts/is-your-language-unreasonable.md) つまり、予測可能性がなぜ重要なのか
* [「ローマ数字のカタと解説」に関するコメント](../posts/roman-numeral-kata.md) ローマ数字のカタに対する私のアプローチ
* [静的に型付けされた関数型プログラミング言語を使用しない 10 の理由](../posts/ten-reasons-not-to-use-a-functional-programming-language.md) 理解できないものへの不満
* [くだらないUML図なんか要らねえよ](../posts/no-uml-diagrams.md) つまり、多くの場合、クラス図用に UML を使用する必要はありません。
